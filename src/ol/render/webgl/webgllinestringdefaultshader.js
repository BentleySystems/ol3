// This file is automatically generated, do not edit
goog.provide('ol.render.webgl.linestringreplay.shader.Default');
goog.provide('ol.render.webgl.linestringreplay.shader.Default.Locations');
goog.provide('ol.render.webgl.linestringreplay.shader.DefaultFragment');
goog.provide('ol.render.webgl.linestringreplay.shader.DefaultVertex');

goog.require('ol.webgl.shader');


/**
 * @constructor
 * @extends {ol.webgl.shader.Fragment}
 * @struct
 */
ol.render.webgl.linestringreplay.shader.DefaultFragment = function() {
  ol.webgl.shader.Fragment.call(this, ol.render.webgl.linestringreplay.shader.DefaultFragment.SOURCE);
};
ol.inherits(ol.render.webgl.linestringreplay.shader.DefaultFragment, ol.webgl.shader.Fragment);
goog.addSingletonGetter(ol.render.webgl.linestringreplay.shader.DefaultFragment);


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultFragment.DEBUG_SOURCE = 'precision mediump float;\nvarying float v_round;\nvarying vec4 v_roundVertex;\nvarying float v_halfWidth;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_color;\nuniform vec2 u_size;\n\nvoid main(void) {\n  if (v_round > 0.0) {\n    vec2 windowCoords = vec2((v_roundVertex.x + 1.0) / 2.0 * u_size.x, (v_roundVertex.y + 1.0) / 2.0 * u_size.y);\n    if (length(windowCoords - gl_FragCoord.xy) > v_halfWidth) {\n      discard;\n    }\n  }\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n';


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultFragment.OPTIMIZED_SOURCE = 'precision mediump float;varying float a;varying vec4 b;varying float c;uniform float l;uniform vec4 m;uniform vec2 n;void main(void){if(a>0.0){vec2 windowCoords=vec2((b.x+1.0)/2.0*n.x,(b.y+1.0)/2.0*n.y);if(length(windowCoords-gl_FragCoord.xy)>c){discard;}} gl_FragColor=m;float alpha=m.a*l;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}';


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultFragment.SOURCE = goog.DEBUG ?
    ol.render.webgl.linestringreplay.shader.DefaultFragment.DEBUG_SOURCE :
    ol.render.webgl.linestringreplay.shader.DefaultFragment.OPTIMIZED_SOURCE;


/**
 * @constructor
 * @extends {ol.webgl.shader.Vertex}
 * @struct
 */
ol.render.webgl.linestringreplay.shader.DefaultVertex = function() {
  ol.webgl.shader.Vertex.call(this, ol.render.webgl.linestringreplay.shader.DefaultVertex.SOURCE);
};
ol.inherits(ol.render.webgl.linestringreplay.shader.DefaultVertex, ol.webgl.shader.Vertex);
goog.addSingletonGetter(ol.render.webgl.linestringreplay.shader.DefaultVertex);


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultVertex.DEBUG_SOURCE = 'varying float v_round;\nvarying vec4 v_roundVertex;\nvarying float v_halfWidth;\n\n\nattribute vec2 a_lastPos;\nattribute vec2 a_position;\nattribute vec2 a_nextPos;\nattribute float a_direction;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform float u_lineWidth;\nuniform float u_miterLimit;\n\nvoid main(void) {\n  v_halfWidth = u_lineWidth / 2.0;\n  vec2 offset;\n  v_round = 0.0;\n  float direction = a_direction / abs(a_direction);\n  vec4 projPos = u_projectionMatrix * vec4(a_position, 0., 1.);\n  if (mod(a_direction, 3.0) == 0.0 || mod(a_direction, 17.0) == 0.0) {\n    vec2 dirVect = a_nextPos - a_position;\n    vec2 normal = normalize(vec2(-dirVect.y, dirVect.x));\n    offset = v_halfWidth * normal * direction;\n    if (mod(a_direction, 2.0) == 0.0) {\n      v_roundVertex = projPos + u_offsetScaleMatrix * vec4(0., 0., 0., 0.);\n    }\n  } else if (mod(a_direction, 5.0) == 0.0 || mod(a_direction, 13.0) == 0.0) {\n    vec2 dirVect = a_lastPos - a_position;\n    vec2 normal = normalize(vec2(dirVect.y, -dirVect.x));\n    offset = v_halfWidth * normal * direction;\n    if (mod(a_direction, 2.0) == 0.0) {\n      v_roundVertex = projPos + u_offsetScaleMatrix * vec4(0., 0., 0., 0.);\n    }\n  } else if (mod(a_direction, 19.0) == 0.0 || mod(a_direction, 23.0) == 0.0) {\n    vec2 dirVect = a_nextPos - a_position;\n    vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n    vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n    vec2 normal = vec2(tangent.y, -tangent.x);\n    float miterLength = v_halfWidth / dot(normal, tmpNormal);\n    if (mod(a_direction, 23.0) == 0.0) {\n      if (mod(a_direction, 2.0) == 0.0) {\n        offset = normal * direction * miterLength;\n        v_round = 1.0;\n        v_roundVertex = projPos + u_offsetScaleMatrix * vec4(0., 0., 0., 0.);\n      } else if (miterLength > u_miterLimit) {\n        offset = tmpNormal * direction * v_halfWidth;\n      } else {\n        offset = normal * direction * miterLength;\n      }\n    } else {\n      offset = normal * direction * miterLength;\n      vec4 defaultOffset = u_offsetScaleMatrix * vec4(0., 0., 0., 0.);\n      vec4 firstProjPos = u_projectionMatrix * vec4(a_lastPos, 0., 1.) + defaultOffset;\n      vec4 secondProjPos = projPos + defaultOffset;\n      vec4 thirdProjPos = u_projectionMatrix * vec4(a_nextPos, 0., 1.) + defaultOffset;\n      float firstSegLength = distance(secondProjPos.xy, firstProjPos.xy);\n      float secondSegLength = distance(thirdProjPos.xy, secondProjPos.xy);\n      float miterSegLength = distance(secondProjPos.xy, vec4(projPos + u_offsetScaleMatrix * vec4(offset, 0., 0.)).xy);\n      //TODO: Write a more accurate method for identifying sharp angles.\n      if (miterSegLength > min(firstSegLength, secondSegLength)) {\n        if (firstSegLength < secondSegLength) {\n          dirVect = a_lastPos - a_position;\n          tmpNormal = normalize(vec2(dirVect.y, -dirVect.x));\n          projPos = firstProjPos - defaultOffset;\n        } else {\n          projPos = thirdProjPos - defaultOffset;\n        }\n        offset = tmpNormal * direction * v_halfWidth;\n      }\n    }\n  } else if (mod(a_direction, 7.0) == 0.0 || mod(a_direction, 11.0) == 0.0) {\n    vec2 normal;\n    if (mod(a_direction, 7.0) == 0.0) {\n      vec2 dirVect = a_position - a_nextPos;\n      vec2 firstNormal = normalize(dirVect);\n      vec2 secondNormal = vec2(firstNormal.y * direction, -firstNormal.x * direction);\n      vec2 hypotenuse = normalize(firstNormal - secondNormal);\n      normal = vec2(hypotenuse.y * direction, -hypotenuse.x * direction);\n    } else {\n      vec2 dirVect = a_position - a_lastPos;\n      vec2 firstNormal = normalize(dirVect);\n      vec2 secondNormal = vec2(-firstNormal.y * direction, firstNormal.x * direction);\n      vec2 hypotenuse = normalize(firstNormal - secondNormal);\n      normal = vec2(-hypotenuse.y * direction, hypotenuse.x * direction);\n    }\n    float length = sqrt(v_halfWidth * v_halfWidth * 2.0);\n    offset = normal * length;\n    if (mod(a_direction, 2.0) == 0.0) {\n      v_round = 1.0;\n      v_roundVertex = projPos + u_offsetScaleMatrix * vec4(0., 0., 0., 0.);\n    }\n  }\n  vec4 offsets = u_offsetScaleMatrix * vec4(offset, 0., 0.);\n  gl_Position = projPos + offsets;\n}\n\n\n';


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultVertex.OPTIMIZED_SOURCE = 'varying float a;varying vec4 b;varying float c;attribute vec2 d;attribute vec2 e;attribute vec2 f;attribute float g;uniform mat4 h;uniform mat4 i;uniform float j;uniform float k;void main(void){c=j/2.0;vec2 offset;a=0.0;float direction=g/abs(g);vec4 projPos=h*vec4(e,0.,1.);if(mod(g,3.0)==0.0||mod(g,17.0)==0.0){vec2 dirVect=f-e;vec2 normal=normalize(vec2(-dirVect.y,dirVect.x));offset=c*normal*direction;if(mod(g,2.0)==0.0){b=projPos+i*vec4(0.,0.,0.,0.);}} else if(mod(g,5.0)==0.0||mod(g,13.0)==0.0){vec2 dirVect=d-e;vec2 normal=normalize(vec2(dirVect.y,-dirVect.x));offset=c*normal*direction;if(mod(g,2.0)==0.0){b=projPos+i*vec4(0.,0.,0.,0.);}} else if(mod(g,19.0)==0.0||mod(g,23.0)==0.0){vec2 dirVect=f-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(tangent.y,-tangent.x);float miterLength=c/dot(normal,tmpNormal);if(mod(g,23.0)==0.0){if(mod(g,2.0)==0.0){offset=normal*direction*miterLength;a=1.0;b=projPos+i*vec4(0.,0.,0.,0.);}else if(miterLength>k){offset=tmpNormal*direction*c;}else{offset=normal*direction*miterLength;}} else{offset=normal*direction*miterLength;vec4 defaultOffset=i*vec4(0.,0.,0.,0.);vec4 firstProjPos=h*vec4(d,0.,1.)+defaultOffset;vec4 secondProjPos=projPos+defaultOffset;vec4 thirdProjPos=h*vec4(f,0.,1.)+defaultOffset;float firstSegLength=distance(secondProjPos.xy,firstProjPos.xy);float secondSegLength=distance(thirdProjPos.xy,secondProjPos.xy);float miterSegLength=distance(secondProjPos.xy,vec4(projPos+i*vec4(offset,0.,0.)).xy);if(miterSegLength>min(firstSegLength,secondSegLength)){if(firstSegLength<secondSegLength){dirVect=d-e;tmpNormal=normalize(vec2(dirVect.y,-dirVect.x));projPos=firstProjPos-defaultOffset;}else{projPos=thirdProjPos-defaultOffset;}offset=tmpNormal*direction*c;}}}else if(mod(g,7.0)==0.0||mod(g,11.0)==0.0){vec2 normal;if(mod(g,7.0)==0.0){vec2 dirVect=e-f;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(firstNormal.y*direction,-firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);normal=vec2(hypotenuse.y*direction,-hypotenuse.x*direction);}else{vec2 dirVect=e-d;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(-firstNormal.y*direction,firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);normal=vec2(-hypotenuse.y*direction,hypotenuse.x*direction);}float length=sqrt(c*c*2.0);offset=normal*length;if(mod(g,2.0)==0.0){a=1.0;b=projPos+i*vec4(0.,0.,0.,0.);}} vec4 offsets=i*vec4(offset,0.,0.);gl_Position=projPos+offsets;}';


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultVertex.SOURCE = goog.DEBUG ?
    ol.render.webgl.linestringreplay.shader.DefaultVertex.DEBUG_SOURCE :
    ol.render.webgl.linestringreplay.shader.DefaultVertex.OPTIMIZED_SOURCE;


/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
ol.render.webgl.linestringreplay.shader.Default.Locations = function(gl, program) {

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_color = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_color' : 'm');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_lineWidth = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_lineWidth' : 'j');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_miterLimit = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_miterLimit' : 'k');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_offsetScaleMatrix = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_offsetScaleMatrix' : 'i');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_opacity = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_opacity' : 'l');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_projectionMatrix' : 'h');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_size = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_size' : 'n');

  /**
   * @type {number}
   */
  this.a_direction = gl.getAttribLocation(
      program, goog.DEBUG ? 'a_direction' : 'g');

  /**
   * @type {number}
   */
  this.a_lastPos = gl.getAttribLocation(
      program, goog.DEBUG ? 'a_lastPos' : 'd');

  /**
   * @type {number}
   */
  this.a_nextPos = gl.getAttribLocation(
      program, goog.DEBUG ? 'a_nextPos' : 'f');

  /**
   * @type {number}
   */
  this.a_position = gl.getAttribLocation(
      program, goog.DEBUG ? 'a_position' : 'e');
};
