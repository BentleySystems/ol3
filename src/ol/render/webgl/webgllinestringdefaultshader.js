// This file is automatically generated, do not edit
goog.provide('ol.render.webgl.linestringreplay.shader.Default');
goog.provide('ol.render.webgl.linestringreplay.shader.Default.Locations');
goog.provide('ol.render.webgl.linestringreplay.shader.DefaultFragment');
goog.provide('ol.render.webgl.linestringreplay.shader.DefaultVertex');

goog.require('ol.webgl.shader');


/**
 * @constructor
 * @extends {ol.webgl.shader.Fragment}
 * @struct
 */
ol.render.webgl.linestringreplay.shader.DefaultFragment = function() {
  ol.webgl.shader.Fragment.call(this, ol.render.webgl.linestringreplay.shader.DefaultFragment.SOURCE);
};
ol.inherits(ol.render.webgl.linestringreplay.shader.DefaultFragment, ol.webgl.shader.Fragment);
goog.addSingletonGetter(ol.render.webgl.linestringreplay.shader.DefaultFragment);


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultFragment.DEBUG_SOURCE = 'precision mediump float;\nvarying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_color;\nuniform vec2 u_size;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  if (v_round > 0.0) {\n    vec2 windowCoords = vec2((v_roundVertex.x + 1.0) / 2.0 * u_size.x * u_pixelRatio,\n        (v_roundVertex.y + 1.0) / 2.0 * u_size.y * u_pixelRatio);\n    if (length(windowCoords - gl_FragCoord.xy) > v_halfWidth * u_pixelRatio) {\n      discard;\n    }\n  }\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n';


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultFragment.OPTIMIZED_SOURCE = 'precision mediump float;varying float a;varying vec2 b;varying float c;uniform float l;uniform vec4 m;uniform vec2 n;uniform float o;void main(void){if(a>0.0){vec2 windowCoords=vec2((b.x+1.0)/2.0*n.x*o,(b.y+1.0)/2.0*n.y*o);if(length(windowCoords-gl_FragCoord.xy)>c*o){discard;}} gl_FragColor=m;float alpha=m.a*l;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}';


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultFragment.SOURCE = goog.DEBUG ?
    ol.render.webgl.linestringreplay.shader.DefaultFragment.DEBUG_SOURCE :
    ol.render.webgl.linestringreplay.shader.DefaultFragment.OPTIMIZED_SOURCE;


/**
 * @constructor
 * @extends {ol.webgl.shader.Vertex}
 * @struct
 */
ol.render.webgl.linestringreplay.shader.DefaultVertex = function() {
  ol.webgl.shader.Vertex.call(this, ol.render.webgl.linestringreplay.shader.DefaultVertex.SOURCE);
};
ol.inherits(ol.render.webgl.linestringreplay.shader.DefaultVertex, ol.webgl.shader.Vertex);
goog.addSingletonGetter(ol.render.webgl.linestringreplay.shader.DefaultVertex);


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultVertex.DEBUG_SOURCE = 'varying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\nattribute vec2 a_lastPos;\nattribute vec2 a_position;\nattribute vec2 a_nextPos;\nattribute float a_direction;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform float u_lineWidth;\nuniform float u_miterLimit;\n\nvoid main(void) {\n  bool degenerate = false;\n  v_halfWidth = u_lineWidth / 2.0;\n  float miterLimit = u_miterLimit + u_lineWidth;\n  vec2 offset;\n  v_round = 0.0;\n  float direction = a_direction / abs(a_direction);\n  vec4 projPos = u_projectionMatrix * vec4(a_position, 0., 1.);\n  v_roundVertex = projPos.xy;\n  if (mod(a_direction, 3.0) == 0.0 || mod(a_direction, 17.0) == 0.0) {\n    vec2 dirVect = a_nextPos - a_position;\n    vec2 normal = normalize(vec2(-dirVect.y, dirVect.x));\n    offset = v_halfWidth * normal * direction;\n  } else if (mod(a_direction, 5.0) == 0.0 || mod(a_direction, 13.0) == 0.0) {\n    vec2 dirVect = a_lastPos - a_position;\n    vec2 normal = normalize(vec2(dirVect.y, -dirVect.x));\n    offset = v_halfWidth * normal * direction;\n  } else if (mod(a_direction, 19.0) == 0.0 || mod(a_direction, 23.0) == 0.0) {\n    vec2 dirVect = a_nextPos - a_position;\n    vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n    vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n    vec2 normal = vec2(-tangent.y, tangent.x);\n    float miterLength = abs(v_halfWidth / dot(normal, tmpNormal));\n    if (mod(a_direction, 23.0) == 0.0) {\n      offset = normal * direction * miterLength;\n      if (mod(a_direction, 2.0) == 0.0) {\n        v_round = 1.0;\n      } else if (miterLength > miterLimit) {\n        offset = tmpNormal * direction * v_halfWidth;\n      }\n    } else {\n      dirVect = a_lastPos - a_position;\n      vec2 longOffset, shortOffset, longVertex;\n      vec4 shortProjVertex;\n      if (length(a_nextPos - a_position) > length(a_lastPos - a_position)) {\n        longOffset = tmpNormal * direction * v_halfWidth;\n        shortOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * v_halfWidth;\n        longVertex = a_nextPos;\n        shortProjVertex = u_projectionMatrix * vec4(a_lastPos, 0., 1.);\n      } else {\n        shortOffset = tmpNormal * direction * v_halfWidth;\n        longOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * v_halfWidth;\n        longVertex = a_lastPos;\n        shortProjVertex = u_projectionMatrix * vec4(a_nextPos, 0., 1.);\n      }\n      //Intersection algorithm based on theory by Paul Bourke (http://paulbourke.net/geometry/pointlineplane/).\n      vec4 p1 = u_projectionMatrix * vec4(longVertex, 0., 1.) + u_offsetScaleMatrix * vec4(longOffset, 0., 0.);\n      vec4 p2 = projPos + u_offsetScaleMatrix * vec4(longOffset, 0., 0.);\n      vec4 p3 = shortProjVertex + u_offsetScaleMatrix * vec4(-shortOffset, 0., 0.);\n      vec4 p4 = shortProjVertex + u_offsetScaleMatrix * vec4(shortOffset, 0., 0.);\n      float denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n      float epsilon = 0.000000000001;\n      float firstU = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\n      float secondU = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\n      if (firstU > epsilon && firstU < 1.0 - epsilon && secondU > epsilon && secondU < 1.0 - epsilon) {\n        gl_Position = shortProjVertex;\n        gl_Position.x = p1.x + firstU * (p2.x - p1.x);\n        gl_Position.y = p1.y + firstU * (p2.y - p1.y);\n        degenerate = true;\n      } else {\n        offset = normal * direction * miterLength;\n      }\n    }\n  } else if (mod(a_direction, 7.0) == 0.0 || mod(a_direction, 11.0) == 0.0) {\n    vec2 normal;\n    if (mod(a_direction, 7.0) == 0.0) {\n      vec2 dirVect = a_position - a_nextPos;\n      vec2 firstNormal = normalize(dirVect);\n      vec2 secondNormal = vec2(firstNormal.y * direction, -firstNormal.x * direction);\n      vec2 hypotenuse = normalize(firstNormal - secondNormal);\n      normal = vec2(hypotenuse.y * direction, -hypotenuse.x * direction);\n    } else {\n      vec2 dirVect = a_position - a_lastPos;\n      vec2 firstNormal = normalize(dirVect);\n      vec2 secondNormal = vec2(-firstNormal.y * direction, firstNormal.x * direction);\n      vec2 hypotenuse = normalize(firstNormal - secondNormal);\n      normal = vec2(-hypotenuse.y * direction, hypotenuse.x * direction);\n    }\n    float length = sqrt(v_halfWidth * v_halfWidth * 2.0);\n    offset = normal * length;\n    if (mod(a_direction, 2.0) == 0.0) {\n      v_round = 1.0;\n    }\n  }\n  if (!degenerate) {\n    vec4 offsets = u_offsetScaleMatrix * vec4(offset, 0., 0.);\n    gl_Position = projPos + offsets;\n  }\n}\n\n\n';


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultVertex.OPTIMIZED_SOURCE = 'varying float a;varying vec2 b;varying float c;attribute vec2 d;attribute vec2 e;attribute vec2 f;attribute float g;uniform mat4 h;uniform mat4 i;uniform float j;uniform float k;void main(void){bool degenerate=false;c=j/2.0;float miterLimit=k+j;vec2 offset;a=0.0;float direction=g/abs(g);vec4 projPos=h*vec4(e,0.,1.);b=projPos.xy;if(mod(g,3.0)==0.0||mod(g,17.0)==0.0){vec2 dirVect=f-e;vec2 normal=normalize(vec2(-dirVect.y,dirVect.x));offset=c*normal*direction;}else if(mod(g,5.0)==0.0||mod(g,13.0)==0.0){vec2 dirVect=d-e;vec2 normal=normalize(vec2(dirVect.y,-dirVect.x));offset=c*normal*direction;}else if(mod(g,19.0)==0.0||mod(g,23.0)==0.0){vec2 dirVect=f-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);float miterLength=abs(c/dot(normal,tmpNormal));if(mod(g,23.0)==0.0){offset=normal*direction*miterLength;if(mod(g,2.0)==0.0){a=1.0;}else if(miterLength>miterLimit){offset=tmpNormal*direction*c;}} else{dirVect=d-e;vec2 longOffset,shortOffset,longVertex;vec4 shortProjVertex;if(length(f-e)>length(d-e)){longOffset=tmpNormal*direction*c;shortOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*c;longVertex=f;shortProjVertex=h*vec4(d,0.,1.);}else{shortOffset=tmpNormal*direction*c;longOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*c;longVertex=d;shortProjVertex=h*vec4(f,0.,1.);}vec4 p1=h*vec4(longVertex,0.,1.)+i*vec4(longOffset,0.,0.);vec4 p2=projPos+i*vec4(longOffset,0.,0.);vec4 p3=shortProjVertex+i*vec4(-shortOffset,0.,0.);vec4 p4=shortProjVertex+i*vec4(shortOffset,0.,0.);float denom=(p4.y-p3.y)*(p2.x-p1.x)-(p4.x-p3.x)*(p2.y-p1.y);float epsilon=0.000000000001;float firstU=((p4.x-p3.x)*(p1.y-p3.y)-(p4.y-p3.y)*(p1.x-p3.x))/denom;float secondU=((p2.x-p1.x)*(p1.y-p3.y)-(p2.y-p1.y)*(p1.x-p3.x))/denom;if(firstU>epsilon&&firstU<1.0-epsilon&&secondU>epsilon&&secondU<1.0-epsilon){gl_Position=shortProjVertex;gl_Position.x=p1.x+firstU*(p2.x-p1.x);gl_Position.y=p1.y+firstU*(p2.y-p1.y);degenerate=true;}else{offset=normal*direction*miterLength;}}}else if(mod(g,7.0)==0.0||mod(g,11.0)==0.0){vec2 normal;if(mod(g,7.0)==0.0){vec2 dirVect=e-f;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(firstNormal.y*direction,-firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);normal=vec2(hypotenuse.y*direction,-hypotenuse.x*direction);}else{vec2 dirVect=e-d;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(-firstNormal.y*direction,firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);normal=vec2(-hypotenuse.y*direction,hypotenuse.x*direction);}float length=sqrt(c*c*2.0);offset=normal*length;if(mod(g,2.0)==0.0){a=1.0;}} if(!degenerate){vec4 offsets=i*vec4(offset,0.,0.);gl_Position=projPos+offsets;}}';


/**
 * @const
 * @type {string}
 */
ol.render.webgl.linestringreplay.shader.DefaultVertex.SOURCE = goog.DEBUG ?
    ol.render.webgl.linestringreplay.shader.DefaultVertex.DEBUG_SOURCE :
    ol.render.webgl.linestringreplay.shader.DefaultVertex.OPTIMIZED_SOURCE;


/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
ol.render.webgl.linestringreplay.shader.Default.Locations = function(gl, program) {

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_color = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_color' : 'm');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_lineWidth = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_lineWidth' : 'j');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_miterLimit = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_miterLimit' : 'k');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_offsetScaleMatrix = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_offsetScaleMatrix' : 'i');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_opacity = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_opacity' : 'l');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_pixelRatio = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_pixelRatio' : 'o');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_projectionMatrix' : 'h');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_size = gl.getUniformLocation(
      program, goog.DEBUG ? 'u_size' : 'n');

  /**
   * @type {number}
   */
  this.a_direction = gl.getAttribLocation(
      program, goog.DEBUG ? 'a_direction' : 'g');

  /**
   * @type {number}
   */
  this.a_lastPos = gl.getAttribLocation(
      program, goog.DEBUG ? 'a_lastPos' : 'd');

  /**
   * @type {number}
   */
  this.a_nextPos = gl.getAttribLocation(
      program, goog.DEBUG ? 'a_nextPos' : 'f');

  /**
   * @type {number}
   */
  this.a_position = gl.getAttribLocation(
      program, goog.DEBUG ? 'a_position' : 'e');
};
